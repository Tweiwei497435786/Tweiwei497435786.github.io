<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Enjoying my work!Enjoying my life!">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://www.tortoise.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Enjoying my work!Enjoying my life!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="Enjoying my work!Enjoying my life!">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/assets/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Tortoise</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Enjoying my work!Enjoying my life!</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Tweiwei497435786" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/han-mo-xiang-ning" title="zhihu">zhihu</a>
					        
								<a class="linkedin" target="_blank" href="http://www.cocoachina.com/bbs/u.php?tid=211552" title="linkedin">linkedin</a>
					        
						</div>					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/iOS开发/" style="font-size: 20px;">iOS开发</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/开发技巧/" style="font-size: 10px;">开发技巧</a> <a href="/tags/房屋装修/" style="font-size: 15px;">房屋装修</a> <a href="/tags/旅行计划/" style="font-size: 15px;">旅行计划</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://objccn.io">Objc中国</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.devtang.com">唐巧的技术博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://bluereader.org/rss/25188">Casa Taloyum</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，追求自由与极致…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Tortoise</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/assets/avatar.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Tortoise</h1>
			</hgroup>
			
			<p class="header-subtitle">Enjoying my work!Enjoying my life!</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Tweiwei497435786" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/han-mo-xiang-ning" title="zhihu">zhihu</a>
			        
						<a class="linkedin" target="_blank" href="http://www.cocoachina.com/bbs/u.php?tid=211552" title="linkedin">linkedin</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-国庆节杭州骑行胶东半岛计划" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/26/国庆节杭州骑行胶东半岛计划/" class="article-date">
  	<time datetime="2016-06-26T05:50:25.000Z" itemprop="datePublished">2016-06-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/26/国庆节杭州骑行胶东半岛计划/">国庆节杭州骑行胶东半岛计划</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<h3 id="出行概要"><a href="#出行概要" class="headerlink" title="出行概要"></a>出行概要</h3></blockquote>
<p>活动时间：2016.9.28–2016.10.7</p>
<p>活动目的：骑游，赏景</p>
<p>道路状况：平坦路面为主</p>
<p>出发时间：2016.9.27</p>
<p>回程时间：2016.10.7</p>
<p>路程：1200KM+</p>
<p>活动强度：强</p>
<p>活动费用：含路费计划1500以内</p>
<p>联系人：Tweiwei497435786[微信] </p>
<blockquote>
<h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h3></blockquote>
<p>总行者路书编号：675752</p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/lushuguoqingjiejiaodongbandao.png" alt="Markdown preferences pane"></p>
<p>分段路书编号：见下面每天行程</p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/jiaodongbandao_lushu.png" alt="Markdown preferences pane"></p>
<blockquote>
<h3 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h3></blockquote>
<h4 id="Day1-杭州乘坐大巴到南通南通汽车客运东站（0KM）"><a href="#Day1-杭州乘坐大巴到南通南通汽车客运东站（0KM）" class="headerlink" title="Day1 杭州乘坐大巴到南通南通汽车客运东站（0KM）"></a>Day1 杭州乘坐大巴到南通南通汽车客运东站（0KM）</h4><p><code>9.28 周三</code>16:30（杭州北站）集合出发乘坐大巴到南通，预计（晚上21:00左右达到南通，提前预定好宾馆住宿入住。</p>
<p>杭州天气：</p>
<p>南通天气：</p>
<p>说明：</p>
<p>（1）<a href="http://bus.ctrip.com/buslist.html?allianceid=30613&amp;sid=555538&amp;ouid=000401app-&amp;utm_medium=onebox&amp;utm_campaign=bus&amp;utm_source=baidu_pc&amp;&amp;isctrip=&amp;from=杭州&amp;to=南通&amp;ctm_ref=baidu_pc" target="_blank" rel="external">杭州 - 南通</a>，选择当天最晚时间点班次的汽车，汽车费用（120不包含自行车托运），汽车预计耗费4个小时。</p>
<h4 id="Day2-南通汽车客运东站－盐城（150KM）"><a href="#Day2-南通汽车客运东站－盐城（150KM）" class="headerlink" title="Day2 南通汽车客运东站－盐城（150KM）"></a>Day2 南通汽车客运东站－盐城（150KM）</h4><p><code>9.29 周四</code>6:30起床，南通汽车客运东站附近吃完早餐，预计下午6:30左右到达盐城市，选择住宾馆或者帐篷。</p>
<p>路况：S225,G228(路书编号:675795)</p>
<p>沿路风景名胜：</p>
<p>南通天气：</p>
<p>盐城天气：</p>
<p>说明：</p>
<h4 id="Day3-盐城市－连云港（160KM）"><a href="#Day3-盐城市－连云港（160KM）" class="headerlink" title="Day3 盐城市－连云港（160KM）"></a>Day3 盐城市－连云港（160KM）</h4><p><code>9：30 周五</code>6:30起床，收拾整理吃完早餐出发，预计下午7：00左右到达连云港连云区，选择在连云港港务局附近露营。</p>
<p>路况：G228(路书编号:675795)</p>
<p>沿路风景名胜：</p>
<p>盐城天气：</p>
<p>连云港天气：</p>
<p>说明：</p>
<h4 id="Day4-连云港－日照市区（170KM）"><a href="#Day4-连云港－日照市区（170KM）" class="headerlink" title="Day4 连云港－日照市区（170KM）"></a>Day4 连云港－日照市区（170KM）</h4><p><code>10.1 周六</code>6:30起床，收拾整理吃完早餐出发，预计下午7：30左右到达日照市区，选择在市区住宾馆或者海边露营。</p>
<p>路况：G228,G204,滨海沿路,碧海路(路书编号:570172)</p>
<p>沿路风景名胜：</p>
<p>连云港天气：</p>
<p>日照市天气：</p>
<p>说明：</p>
<h4 id="Day5-日照市－青岛市（135KM）"><a href="#Day5-日照市－青岛市（135KM）" class="headerlink" title="Day5 日照市－青岛市（135KM）"></a>Day5 日照市－青岛市（135KM）</h4><p><code>10.2 周日</code>6:30起床，收拾整理吃完早餐出发，预计下午4：00左右到达青岛市（崂山国家森林公园），选择在海边露营。</p>
<p>路况：G204,S293,S329,薛家岛港，S214(路书编号:570181)</p>
<p>沿路风景名胜：</p>
<p>日照市天气：</p>
<p>青岛市天气：</p>
<p>说明：路程相对较少，青岛有许多好玩的地方，可以多晚一些地方，选择海边露营。</p>
<h4 id="Day6-青岛－乳山市（140KM）"><a href="#Day6-青岛－乳山市（140KM）" class="headerlink" title="Day6 青岛－乳山市（140KM）"></a>Day6 青岛－乳山市（140KM）</h4><p><code>10.3 周一</code>6:30起床，收拾整理吃完早餐出发，预计下午5：00左右到达青岛市（崂山国家森林公园），选择住宿宾馆。</p>
<p>路况：S293,S202(路书编号:570189)</p>
<p>沿路风景名胜：</p>
<p>青岛市天气：</p>
<p>乳山市天气：</p>
<p>说明：</p>
<h4 id="Day7-乳山市－威海市（215KM）"><a href="#Day7-乳山市－威海市（215KM）" class="headerlink" title="Day7 乳山市－威海市（215KM）"></a>Day7 乳山市－威海市（215KM）</h4><p><code>10.4 周二</code>6:30起床，收拾整理吃完早餐出发，预计下午5：00左右到达青岛市（崂山国家森林公园），选择住宿宾馆。</p>
<p>路况：S293,S202(路书编号:570199)</p>
<p>沿路风景名胜：</p>
<p>乳山市天气：</p>
<p>威海市天气：</p>
<p>说明：该段路程规划的沿海骑行，可能路线是这几天中最重的路线。(该段路线较差或者沿路风景一般)可考虑走直线距离直接到达威海市。</p>
<h4 id="Day8-威海市－烟台市-蓬莱市（150KM）"><a href="#Day8-威海市－烟台市-蓬莱市（150KM）" class="headerlink" title="Day8 威海市－烟台市 - 蓬莱市（150KM）"></a>Day8 威海市－烟台市 - 蓬莱市（150KM）</h4><p><code>10.5 周三</code>6:30起床，收拾整理吃完早餐出发，预计下午6：00左右到达蓬莱市，选择露营或者住宿宾馆。</p>
<p>路况：S302,S264,G206(路书编号:570222)</p>
<p>沿路风景名胜：</p>
<p>威海市天气：</p>
<p>烟台市天气：</p>
<p>蓬莱市天气：</p>
<p>说明：</p>
<h4 id="Day9-蓬莱市－潍坊市（195KM）"><a href="#Day9-蓬莱市－潍坊市（195KM）" class="headerlink" title="Day9 蓬莱市－潍坊市（195KM）"></a>Day9 蓬莱市－潍坊市（195KM）</h4><p><code>10.6 周四</code>6:30起床，收拾整理吃完早餐出发，预计下午8：00左右到达潍坊市，选择住宿宾馆。</p>
<p>路况：G206(路书编号:570225)</p>
<p>沿路风景名胜：</p>
<p>蓬莱市天气</p>
<p>潍坊天气：</p>
<p>说明：</p>
<h4 id="Day10-潍坊市-杭州（高铁）"><a href="#Day10-潍坊市-杭州（高铁）" class="headerlink" title="Day10 潍坊市- 杭州（高铁）"></a>Day10 潍坊市- 杭州（高铁）</h4><p><code>10.7 周五</code>9:30起床，收拾整理吃完早餐出发，下午15:00到达潍坊火车站，乘坐下午15:48的高铁准备回杭州。</p>
<p>路况：</p>
<p>沿路风景名胜：</p>
<p>潍坊天气：</p>
<p>杭州天气：</p>
<p>说明：</p>
<p>（1）乘坐<a href="http://train.qunar.com/stationToStation.htm?fromStation=潍坊&amp;toStation=杭州&amp;date=2016-06-27&amp;ex_track=bd_aladin_train_p2p_title&amp;ex_track=bd_aladin_train_p2p_title" target="_blank" rel="external">G256</a>次高铁回杭州，时长6个小时左右，费用450，预计晚上21:40到达火车东站。</p>
<blockquote>
<h3 id="预计费用"><a href="#预计费用" class="headerlink" title="预计费用"></a>预计费用</h3></blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">费用</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">住宿</td>
<td style="text-align:center">4 * 80 = 320</td>
<td style="text-align:center">自带帐篷+宾馆，总共出行9天，按照一半住宿宾馆，费用80/天</td>
</tr>
<tr>
<td style="text-align:center">餐费</td>
<td style="text-align:center">9 * 50 ＝ 450</td>
<td style="text-align:center">餐费包含水</td>
</tr>
<tr>
<td style="text-align:center">自行车托运</td>
<td style="text-align:center">70 + 120 = 210</td>
<td style="text-align:center">去大巴直接随车，回程办理火车托运非随车</td>
</tr>
<tr>
<td style="text-align:center">车费</td>
<td style="text-align:center">120 + 450 = 570</td>
<td style="text-align:center">大巴，高铁</td>
</tr>
<tr>
<td style="text-align:center">其它费用</td>
<td style="text-align:center">未知</td>
<td style="text-align:center">包含个人消费等</td>
</tr>
<tr>
<td style="text-align:center">总计</td>
<td style="text-align:center">1550</td>
<td style="text-align:center">当前费用为大概统计，具体依据消费而定</td>
</tr>
</tbody>
</table>
<blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></blockquote>
<p>1.由于时间关系，本计划只是大概的行程计划，本次出行时间不低于8天，后期可考虑裁剪路线或者增加出行日程，大家注意时间安排。</p>
<p>2.关于行程中的景点，天气会在出行之前不断完善，期望大家多出主意，可以尽快联系我。</p>
<p>2.期望大家能够在出游之前提出更多的建议，将会根据相关建议做出修改。让大家都能有一个开心，快乐美好的骑行游玩旅程。</p>
<p>3.戴好头盔手套与能量补给；需要带基本衣物，手电，防雨装备，防晒，基本药物等。</p>
<p>4.本次出行采取露营方式，需要自备帐篷。</p>
<p>5.本次活动强度较大骑行9天，需参与人员能够有150KM/天的骑行经验。</p>
<blockquote>
<h3 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h3></blockquote>
<p>1.本活动是自发的，有一定的危险性，参加者须对自己的安全负责。活动中当由于意外事故或急性疾病等不可预测因素造成身体损伤时，团队的其他成员会尽全力救助，但不承担任何法律和经济责任，望能理解。</p>
<p>2.任何参与本活动的人均视为同意此免责声明。</p>
<blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3></blockquote>
<p>1.<a href="http://bbs.biketo.com/thread-792308-1-1.html" target="_blank" rel="external">上海骑行青岛路上拍照</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/旅行计划/">旅行计划</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-房屋装修之装修步骤" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/25/房屋装修之装修步骤/" class="article-date">
  	<time datetime="2016-06-25T02:41:13.000Z" itemprop="datePublished">2016-06-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/25/房屋装修之装修步骤/">房屋装修之装修步骤</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>装修的步骤一般包含如下的基本21个步骤:</p>
<p>1.前期设计 – 2.主体拆改 – 3.水电改造 – 4.木工 – 5.贴砖 – 6.刷墙面漆 – 7.热水器安装 – 8.厨卫吊顶 – 9.橱柜安装– 10.烟机灶安装 – 11.木门安装 – 12.地板安装 – 13.铺贴壁纸 – 14. 开关插座安装 – 15.灯具安装 – 16.五金洁具安装 – 17.窗帘杆安装 – 18.拓荒保洁 – 19.家具进场 – 20.家电安装 – 21.家居配饰</p>
<p>接下来将会对21环节拆分讲解及需要注意的事项：</p>
<h4 id="一-前期设计"><a href="#一-前期设计" class="headerlink" title="一 前期设计"></a>一 前期设计</h4><p>在前期设计前，需要对房子做一个详细的测量，测量需要包括(下面是原平面图):<code>原设计图，原设计图线路图</code>，墙体厚度，原开关线路的位置等，原来门窗的宽高度，原墙面的宽高度，原开关的位置，不可动墙体部分等具体的位置坐标。</p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/fangwujiancaotuyuantu.JPG" alt="Markdown preferences pane"></p>
<p>做完以上的原设计图等内容，是方便重新设计出符合自己装修的图纸，在原来的基础上适当的改拆，进行二次设计。</p>
<p>选定装修风格，开始利用sweethome工具进行初期设计，在原设计图上改拆等具体的都要标注清楚。</p>
<p>1.设计好装修图之后，需要设计好家居的摆放位置，进行渲染后看效果图，确定好所有的家居，灯，家电,五金，等设备摆放位置后，可以根据设计图进行电路图的设计，开关位置，开关数量都需要确定（数量，坐标位置）将这些信息标注都在设计图上面标注清楚。</p>
<p>2.根据墙面等大小，摆放各种家具装置，确定大小位置高度，后期方便家具购买。（注意各家具的大小都需要具体的坐标大小)</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>1.<a href="http://jingyan.baidu.com/article/7f766daf7bc9b34100e1d044.html" target="_blank" rel="external">装修房子的过程</a></p>
<p>2.<a href="http://mt.sohu.com/20150310/n409584382.shtml" target="_blank" rel="external">史上最详细的房屋装修流程，看懂了再装！不收藏可惜！！！</a></p>
<p>3.<a href="http://www.sweethome3d.com/zh-tw/userGuide.jsp" target="_blank" rel="external">Sweet Home 3D 使用者指南</a></p>
<p>4.<a href="http://www.ooopic.com" target="_blank" rel="external">昵图网素材</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/房屋装修/">房屋装修</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-xcodebuild-xcrun-simctl" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/22/xcodebuild-xcrun-simctl/" class="article-date">
  	<time datetime="2016-06-22T02:22:22.000Z" itemprop="datePublished">2016-06-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/22/xcodebuild-xcrun-simctl/">xcodebuild  xcrun simctl</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在iOS中打包是一件繁琐且重复耗时的工作，而且手动操作还会遇到一些操作错误的问题。而且随着iOS的渠道增多更加会浪费额外的时间，在前面的文中有讲到过使用jenkins或者fastlane打包的工具，那么本篇将会讲解如果通过xcode提供的的shell编译工具xcodebuild，xcrun，xcrun simtil等进行相应的打包自动化操作。下面会简单的列举一些操作，更多请查看对应的–help。</p>
<h4 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h4><p>xcodebuild负责将工程源文件编译成xxx.app</p>
<p>在terminate中输入以下命令xcodebuild –help：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tianww@tortoise-MacBook-Pro xcodebuild --help</span><br></pre></td></tr></table></figure>
<p>可以查看的到xcodebuild的相关的可用命令：</p>
<p>显示xcodebuildversion：xcodebuild –version</p>
<p>显示当前系统安装的sdk：xcodebuild –showsdks</p>
<p>显示当前目录下project Information：xcodebuild –list</p>
<p> <code>需要注意以上命令是需要在当前的工程.xcodeproj下执行</code></p>
<p> 清理iphoneos下的.app文件xcodebuild clean</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$xcodebuild clean -workspace BeiBeiAPP.xcworkspace -scheme beibei -configuration release -sdk iphoneos SYMROOT=`pwd`/build_yueyu</span><br></pre></td></tr></table></figure>
<p> 以下是通过xcodebuild生成workspace类型的.app文件，注意如果是xcodeproj类型打包的话就选择<code>-project</code>，注意此时需要设置好项目的codesign选择自动即可。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$xcodebuild -workspace BeiBeiAPP.xcworkspace -scheme beibei -configuration release -sdk iphoneos build SYMROOT=`pwd`/build_yueyu</span><br></pre></td></tr></table></figure>
<h4 id="xcrun"><a href="#xcrun" class="headerlink" title="xcrun"></a>xcrun</h4><p>xcrun负责给xxx.app(签名)并打包成xxx.ipa</p>
<p>在terminate中输入以下命令xcrun –help，可以查看到xcrun的相关所有的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tianww@tortoise-MacBook-Pro xcrun --help</span><br></pre></td></tr></table></figure>
<p>以下通过.app文件生成ipa文件，并且签名的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/xcrun -sdk iphoneos PackageApplication -v &quot;$distDir/$appName.app&quot; -o &quot;$distDir/$channelId.ipa&quot; --sign &quot;09E378E966D47195A553BE0EF9F0790D4997A9B5&quot;</span><br></pre></td></tr></table></figure>
<p>其中，参数 v 就是 build 结果中最后一行 app 文件的路径，参数 o 是生成的 ipa 文件的路径。</p>
<h4 id="xcrun-simctl"><a href="#xcrun-simctl" class="headerlink" title="xcrun simctl"></a>xcrun simctl</h4><p>通过xcrun simtil相关命令可以调度模拟器的操作，包括安装卸载启动等。</p>
<p>在terminate中输入以下命令xcrun simctl –help，可以查看到xcrun simctl的相关所有的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tianww@tortoise-MacBook-Pro xcrun simctl --help</span><br></pre></td></tr></table></figure>
<p>如下简单的写了一个自动启动模拟器，并安装相关APP，并且自动启动的shell脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ouput xcrun instuments list--&gt;&quot;</span><br><span class="line">xcrun instruments -s #列举当前机器的所有的instruments列表</span><br><span class="line">echo &quot;select instruments device and run---&gt;&quot;</span><br><span class="line">xcrun instruments -w &quot;iPhone 6s (9.3)#[DEB8527E-87D4-4BCE-BDE3-12CAB9463669] (Simulator)&quot; #根据列举的instruments，调用对应的设备</span><br><span class="line">echo &quot;install app--&gt;&quot;</span><br><span class="line">xcrun simctl install booted ~/Desktop/BridgeLabiPhone.app #安装对应地址下的.app文件到上面选择的设备</span><br><span class="line">echo &quot;run app--&gt;&quot;</span><br><span class="line">xcrun simctl launch booted &quot;com.redcat.shandiangou.daily&quot; #启动模拟器，需要传入对应的bundle identifier</span><br></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>1.<a href="http://mobile.51cto.com/hot-439106.htm" target="_blank" rel="external">iOS自动化的打渠道包解决方案</a></p>
<p>2.<a href="http://www.cnblogs.com/qq78292959/archive/2011/06/14/2080751.html" target="_blank" rel="external">xcodebuild 使用手册</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-多线程理解之NSThread" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/31/iOS-多线程理解之NSThread/" class="article-date">
  	<time datetime="2016-05-31T09:15:05.000Z" itemprop="datePublished">2016-05-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/31/iOS-多线程理解之NSThread/">iOS 多线程理解之NSThread</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>关于iOS中多线程知识已经有无数前辈总结过，文章的好坏参差不齐，多线程的问题似乎是成为一个高手必修炼的内功。如果说在面试过程中面试官必出的一道题，那么非多线程内容不可，iOS中的多线程开发真的有那么难么？下面是本人的一些总结，当然也参考了前人比较好的文章，只有去实践才能深刻的理解，下面会分三篇去讲解。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>多线程（multithreading)，是指从<code>软件</code>或者<code>硬件</code>上实现多个线程并发执行的技术。在一个程序中，独立运行的程序片段叫做“线程”(Thread)。每个正在系统上运行的程序都是一个进程，每个进程包含一到多个线程。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行，线程基本上是轻量级的进程，它负责在单个程序里执行多个任务。通常由操作系统负责多个线程的调度和执行。线程是程序中一个单一的循序控制流程，在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p>
<p>在单一的线程中，一件事情没有处理完林外一件事情就不能开始，这样则会影响用户体验。在单核处理器时期就有多线程，这个时候多线程更多的用于解决线程阻塞造成的用户等待（通常是操作完UI后用户不再干涉，其它的线程在等待队列中，CPU一旦空闲就继续执行，不影响用户其它UI操作），其处理能力并没有变化。如今无论移动还是PC，服务器都是多核处理，于是<code>并行运算</code>就更多的提及。一件事情我们可以划分为多个步骤，在没有顺序要求的情况下使用多线程技能解决线程阻塞又能充分利用多核处理器运行能力。</p>
<p>下图反映了一个包含8个操作的任务在一个有两核心的CPU中创建四个线程运行的情况。假设每个核心有两个线程，那么每个CPU中两个线程会交替执行，两个CPU之间的操作会并行运算。单就一个CPU而言两个线程可以解决线程阻塞造成的不流畅问题，其本身运行效率并没有提高，多CPU的并行运算才真正解决了运行效率问题，这也正是并发和并行的区别。当然，不管是多核还是单核开发人员不用过多的担心，因为任务具体分配给几个CPU运算是由系统调度的，开发人员不用过多关心系统有几个CPU。开发人员需要关心的是线程之间的依赖关系，因为有些操作必须在某个操作完成完才能执行，如果不能保证这个顺序势必会造成程序问题。</p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/202333357067475.png" alt="General preferences"></p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>1.使用线程可以把占据时间长的程序中的任务放到后台去处理</p>
<p>2.程序的运行速度可能加快（多核更突出）</p>
<p>……</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>1.大量的的线程，会影响性能，因为操作系统需要在他们之间来回切换</p>
<p>2.更多的线程需要更多的内存空间</p>
<p>3.多线程的情况下可能会带来线程操作不当的bug，需要考虑线程之间的资源共享，线程死锁的情况。</p>
<h4 id="iOS多线程"><a href="#iOS多线程" class="headerlink" title="iOS多线程"></a>iOS多线程</h4><p>在iOS中每个应用程序（进程）启动后都会建立主线程(UI线程)，这个线程被称作其它线程的父线程。如下代码中展示,在main函数中打印发现主线程已经创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    NSLog(@&quot;应用程序启动的时候在main函数中创建了主线程.......:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于在iOS中除了主线程，其它子线程是独立于Cocoa Touch的，所以只有<a href="http://www.lai18.com/content/1432808.html" target="_blank" rel="external">主线程可以更新UI界面</a>（同时UI的操作是非线程安全的，如果苹果大量UI部分UIKit设计为线程安全的，将会是非常耗性能的，同时会造成资源共享的bug等。当然新版本iOS中，部分UIFont，UIColor绘图等UI操作已经被设计为线程安全的，但是还是建议UI的操作保证在主线程中执行）。iOS中使用多线程并不复杂，关键是如何控制好各个线程的执行的循序，处理好资源竞争问题。常用的多线程开发有三种方式：</p>
<ul>
<li>NSThread</li>
<li>NSOperation</li>
<li>GCD</li>
</ul>
<p>当然使用各多线程的方式需要考虑当前具体的需求场景，甚至在项目中需要结合多种方式使用。具体的在了解完各自的具体使用后，具体的分析各自的优缺点及使用场景。</p>
<blockquote>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3></blockquote>
<p>NSThread是轻量级的多线程开发，使用起来并不复杂，但是需要管理线程的生命周期(线程的创建create，启动start，调度cancle等）,无法有效控制线程数量。可以通过两种方式来创建线程，实例方法，类方法创建如下：</p>
<p>通过实例方法调用（需要管理其生命周期）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//使用alloc的方式创建一个新的线程，不会阻塞当前的ui主线程的操作</span><br><span class="line">NSThread *myThread = [[NSThread alloc] initWithTarget:self selector:@selector(loadImage:) object:nil];</span><br><span class="line">[myThread start];//启动线程</span><br></pre></td></tr></table></figure>
<p>通过类方法直接创建调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//通过类方法直接隐式创建,每次都会创建一条新的线程</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(loadImage:) toTarget:self withObject:nil];</span><br></pre></td></tr></table></figure>
<p>通过NSThread可以解决线程阻塞的问题，在通过其它线程进行图片等资源下载过程中，保证主线程UI操作不会阻塞。其它线程操作完成，通过调用主线程的方式操作UI。</p>
<h5 id="NSObject-NSThreadPerformAdditions"><a href="#NSObject-NSThreadPerformAdditions" class="headerlink" title="NSObject (NSThreadPerformAdditions)"></a>NSObject (NSThreadPerformAdditions)</h5><p>为了简单操作，苹果提供了NSOject分类扩展方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (NSThreadPerformAdditions)</span><br><span class="line"></span><br><span class="line">//在主线程上执行一个方法</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">	// equivalent to the first method with kCFRunLoopCommonModes </span><br><span class="line"></span><br><span class="line">//在指定的线程上执行一个方法，需要用户创建一个线程对象</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array NS_AVAILABLE(10_5, 2_0);</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait NS_AVAILABLE(10_5, 2_0);</span><br><span class="line">	// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">//在后台执行一个操作，本质就是重新创建一个线程执行当前方法	</span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg NS_AVAILABLE(10_5, 2_0);</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="多个线程并发-Concurrent"><a href="#多个线程并发-Concurrent" class="headerlink" title="多个线程并发(Concurrent)"></a>多个线程并发(Concurrent)</h5><p>使用NSThread创建多个线程，下载图片并且在相应的UIImageview中展示，通过以下场景来了解并发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)changeImage:(MultiModel *)model</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;index....:%ld&quot;,model.index);</span><br><span class="line">    NSData *data = [self requestData:model.imagUrl];</span><br><span class="line">    model.imageData = data;</span><br><span class="line">    //更新的操作放到主线程中操作</span><br><span class="line">    [_multiThreadView performSelector:@selector(updateImageView:) onThread:[NSThread mainThread] withObject:model waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.当前图片请求操作都在主线程执行，当前主线程阻塞，在点击加载按钮后图片没有请求完成的情况下无法，点击顶部的返回操作,所有图片全部请求完成后一起显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//当前主线程阻塞，在点击加载按钮后图片没有请求完成的情况下无法，点击顶部的返回操作</span><br><span class="line">//所有图片全部请求完成后一起显示</span><br><span class="line">[self changeImage:model];</span><br></pre></td></tr></table></figure>
<p>2.每一个图片的展示使用一个NSThread线程进行请求图片的操作。由于selector不能传递多个参数，可以将数据进行对象封装处理。当点击加载后，可以点击返回到主页，不会阻塞当前的主线程的任何操作（返回首页后，子线程依旧输出内容）。虽然图片是按循序请求的，但是图片的显示顺序不是有序的，由于网络的原因每个请求线程时间都不一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(changeImage:) object:model];</span><br><span class="line">           thread.name = [NSString stringWithFormat:@&quot;线程%ld&quot;,index];</span><br><span class="line">           [thread start];</span><br></pre></td></tr></table></figure>
<p>3.为了能够控制线程执行顺序，通过控制最后一张图片最后展示在最后展示，可以通过当前为1张图片的线程操作的时候，使得图片1的线程（线程0）休眠一段时间达到最后展示，实际测试多次发现并非图片1每一都是最后展示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)delay:(MultiModel *)model</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;index....:%ld&quot;,model.index);</span><br><span class="line">    if (model.index == 0) &#123;//控制第一张图片，最后展示</span><br><span class="line">        NSLog(@&quot;[NSThread currentThread].....:%@&quot;,[NSThread currentThread]);</span><br><span class="line">        [NSThread sleepForTimeInterval:20];</span><br><span class="line">    &#125;</span><br><span class="line">    NSData *data = [self requestData:model.imagUrl];</span><br><span class="line">    model.imageData = data;</span><br><span class="line">    //更新的操作放到主线程中操作</span><br><span class="line">    [_multiThreadView performSelector:@selector(updateImageView:) onThread:[NSThread mainThread] withObject:model waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.当然我们也可以通过修改线程的优先级来控制，图片展示的顺序。线程优先级范围为0~1，值越大优先级越高，每个线程的优先级默认为0.5。修改图片下载方法如下，改变最后一张图片加载的优先级，这样可以提高它被优先加载的几率，但是它也未必就第一个加载:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)priority:(MultiModel *)model</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;index....:%ld&quot;,model.index);</span><br><span class="line">    if (model.index == 8) &#123;//控制最后一个最先加载，设置优先级最高</span><br><span class="line">        NSLog(@&quot;[NSThread currentThread].....:%@&quot;,[NSThread currentThread]);</span><br><span class="line">        [NSThread setThreadPriority:1.0];</span><br><span class="line">    &#125;</span><br><span class="line">    NSData *data = [self requestData:model.imagUrl];</span><br><span class="line">    model.imageData = data;</span><br><span class="line">    //更新的操作放到主线程中操作</span><br><span class="line">    [_multiThreadView performSelector:@selector(updateImageView:) onThread:[NSThread mainThread] withObject:model waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明NSThread的并发操作，并不能有效的保证执行顺序，由于图片加载的顺序以及网络的原因。</p>
<h5 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h5><p>线程的状态有三种如下，都是只读操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, getter=isExecuting) BOOL executing NS_AVAILABLE(10_5, 2_0);//判断是否在执行</span><br><span class="line">@property (readonly, getter=isFinished) BOOL finished NS_AVAILABLE(10_5, 2_0);//判断执行是否完成</span><br><span class="line">@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);//判断执行是否取消</span><br></pre></td></tr></table></figure>
<h5 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h5><p>在线程操作过程中可以让某个线程休眠等待，优先执行其他线程操作，而且在这个过程中还可以修改某个线程的状态或者终止某个指定线程。比喻上面并发过程中讲到的线程睡眠，优先级的操作。有下面方法可以控制线程的生命周期，包含类方法和实例方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (void)sleepUntilDate:(NSDate *)date;</span><br><span class="line">+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</span><br><span class="line"></span><br><span class="line">+ (void)exit;</span><br><span class="line"></span><br><span class="line">+ (double)threadPriority;</span><br><span class="line">+ (BOOL)setThreadPriority:(double)p;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, getter=isCancelled) BOOL cancelled NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">- (void)cancel NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">- (void)start NS_AVAILABLE(10_5, 2_0);</span><br><span class="line"></span><br><span class="line">- (void)main NS_AVAILABLE(10_5, 2_0);	// thread body method</span><br></pre></td></tr></table></figure>
<p>在用户并发加载了图片操作，立马取消所有线程操作。通过线程的状态，改变线程的生命周期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)exitAllThread</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;取消所有的线程&quot;);</span><br><span class="line">    //注意如果仅仅是在这里cancel，实际上是不能阻止子线程继续执行，还需要在线程加载数据的时候，取消掉exit</span><br><span class="line">    [self.threadArray enumerateObjectsUsingBlock:^(NSThread * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        if (![obj isFinished]) &#123;</span><br><span class="line">            [obj cancel];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;index....:%ld&quot;,model.index);</span><br><span class="line">    if (model.index &gt; 6) &#123;</span><br><span class="line">       [NSThread sleepForTimeInterval:2];//等待主线程中取消后2s再判断，7，8线程是否取消，取消后则退出当前线程，配合断点不怎好控制</span><br><span class="line">        if ([[NSThread currentThread] isCancelled]) &#123;//当前在主线程中已经被cancle了</span><br><span class="line">            [NSThread exit];//取消掉当前的线程</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSData *data = [self requestData:model.imagUrl];</span><br><span class="line">    model.imageData = data;</span><br><span class="line">    //更新的操作放到主线程中操作</span><br><span class="line">    [_multiThreadView performSelector:@selector(updateImageView:) onThread:[NSThread mainThread] withObject:model waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用NSThread在进行多线程开发过程中操作比较简单，但是要控制线程执行顺序并不容易（前面万不得已采用了休眠的方法），另外在这个过程中如果打印线程会发现循环几次就创建了几个线程，这在实际开发过程中是不得不考虑的问题，因为每个线程的创建也是相当占用系统开销的。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>1.本篇文章详细demo<a href="https://github.com/Tweiwei497435786/multiThreadingTest" target="_blank" rel="external">multiThreadingTest</a></p>
<p>2.<a href="http://baike.baidu.com/link?url=avVQJXUNwjVPgGarmWSvyFrLkQYgfXvSgXeSMLv29_L0CptvLlEeUUdzvVmvOYZP25OOmlLpFrh2USlDw0KsH_" target="_blank" rel="external">多线程</a></p>
<p>3.<a href="http://www.cnblogs.com/kenshincui/p/3983982.html#otherArticle" target="_blank" rel="external">iOS开发系列–并行开发其实很容易</a></p>
<p>4.<a href="http://www.cocoachina.com/ios/20150807/12911.html" target="_blank" rel="external">超详细！iOS 并发编程之 Operation Queues</a></p>
<p>5.<a href="http://www.cnblogs.com/yangecnu/p/3164167.html" target="_blank" rel="external">浅谈并发与并行</a></p>
<p>6.<a href="http://3961409.blog.51cto.com/3951409/759708" target="_blank" rel="external">并发和并行的区别</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-房屋装修设计基础" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/28/房屋装修设计基础/" class="article-date">
  	<time datetime="2016-05-28T07:46:28.000Z" itemprop="datePublished">2016-05-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/28/房屋装修设计基础/">房屋装修设计基础</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>房子总算是买了，房屋装修设计可也是一大麻烦事，纠结于全包还是半包。全包担心最后结果不是自己想要的，质量上可能会打折扣；半包太麻烦，没有那么多时间。有人说“房屋设计装修一直到完工所需的知识不亚于高考”，总之综合各种考虑之后，我选择了半包，基本的设计图纸，装修搭配，材料购买全部自己来负责。想想之后完工的效果，应该是很有成就感吧！</p>
<h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>1.你需要看大量的各种设计效果图，确定选择自己喜欢的风格。搜罗各种装修技巧，前人遇到的各种坑。那么这些你一定要注意了。</p>
<p>2.电脑操作技巧等。</p>
<p>3.水电设计（大量的参考博文）</p>
<p>4.审美（继续参考）</p>
<h3 id="设计工具"><a href="#设计工具" class="headerlink" title="设计工具"></a>设计工具</h3><p>关于房屋平面设计你是不是一无所知，什么CAD等各种各样的设计软件，是不是觉得很迷茫，总之是无从下手。下面介绍的工具等内容，可以让你轻松的实现自己设计效果，并且可以根据自己的喜好实时做出修改。</p>
<p><a href="http://www.hanzify.org/?Go=Show::List&amp;ID=12421" target="_blank" rel="external">Sweet Home 3D</a>这款工具可以帮你轻松搞定装修设计图，效果图，操作简单实用。注意这里是Mac OXS版本的，Windows请自行度娘。</p>
<p>由于Sweet Home 3D自带的素材（家居，文理）相对来说较少，不怕万能的淘宝能帮助你解决这个问题，2块钱即可买到1千多款素材，你绝对值得拥有，见<a href="https://item.taobao.com/item.htm?_u=snekr3t5e9a&amp;id=22867340651" target="_blank" rel="external">地址</a>.</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>Sweet Home 3D使用起来还是相当简单的，拖拖拽拽一些控件就可以实时看到3D效果。把所有东西都操作一遍基本一上午就可学会了，很简单吧。我不会告诉你，我对装修设计可是一窍不通。</p>
<p>下面附上我花了一天实践设计品面图，和3D效果图，还是很有成就感的呢，后面会根据情况实际做修改调整：</p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/fangwushejipinmian.png" alt="Markdown preferences pane"></p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/fangwusheji3d.png" alt="Markdown preferences pane"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/房屋装修/">房屋装修</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Mac-OSX包管理工具" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/27/Mac-OSX包管理工具/" class="article-date">
  	<time datetime="2016-05-27T09:04:32.000Z" itemprop="datePublished">2016-05-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/27/Mac-OSX包管理工具/">Mac OSX包管理工具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>工欲善其事，必先利其器。在window上面安装工具，直接下载一个安装即可。由于Mac OSX是基于unix架构，在linux上面我们多习惯用命令来安装工具。接下来一些强大的Mac管理工具，作为Mac开发人员你不可不知。</p>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p><a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">Homebrew</a>简称为brew，是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件， 只需要一个命令， 非常方便。</p>
<p>安装brew只需要在终端输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<p>搜索软件：brew search 软件名，如brew search wget</p>
<p>安装软件：brew install 软件名，如brew install wget</p>
<p>卸载软件：brew remove 软件名，如brew remove wget</p>
<p>示例：<a href="http://tweiwei497435786.github.io/2016/03/21/iOS使用Jenkins进行持续集成/" target="_blank" rel="external">上一文中</a>又讲到安装jenkins使用的就是brew方式安装的：<br>brew install jenkins</p>
<h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>NPM是一个Node包管理和分发工具，已经成为了非官方的发布node模块（包）的标准。有了npm，可以很快的找到特定服务要使用的包，进行下载、安装以及管理已经安装的包,前端开发者的必备利器。</p>
<p>在这里我们同样先使用brew安装Npm，Node:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure>
<p>示例：在首篇文章中搭建hexo的时候就是使用npm安装hexo：npm install -g （安装hexo的命令）</p>
<h3 id="Gem"><a href="#Gem" class="headerlink" title="Gem"></a>Gem</h3><p>由于在CocoaPods类库管理工具中需要使用，<a href="https://rubygems.org/pages/download#formats" target="_blank" rel="external">Gem</a>是Ruby（一种跨平台的脚本语言）的环境下的命令，在Mac OXS系统中，已经自动安装了Xcode，Xcode已经安装ruby的环境。</p>
<h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><p>iOS 最新版 CocoaPods 的安装流程</p>
<p>1.移除现有Ruby默认源</p>
<p>$gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a></p>
<p>2.使用新的源</p>
<p>$gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a></p>
<p>3.验证新源是否替换成功</p>
<p>$gem sources -l</p>
<p>4.安装CocoaPods</p>
<p>(1) $sudo gem install cocoapods</p>
<p> 备注：苹果系统升级 OS X EL Capitan 后改为 $sudo gem install -n /usr/local/bin cocoapods</p>
<p>(2) $pod setup</p>
<p>5.更新gem</p>
<p>$sudo gem update –system</p>
<ol>
<li>新建工程，并在终端用cd指令到文件夹内</li>
</ol>
<p>$pod search 第三方</p>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>错误1：</p>
<p>Error fetching <a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>:</p>
<p>bad response Not Found 404 (<a href="http://ruby.taobao.org/specs.4.8.gz" target="_blank" rel="external">http://ruby.taobao.org/specs.4.8.gz</a>)</p>
<p>解决方案：把安装流程中 $gem sources -a <a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>   —改为—-&gt; $gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a></p>
<p>错误2：</p>
<p>ERROR:  While executing gem … (Errno::EPERM)</p>
<p>Operation not permitted - /usr/bin/pod</p>
<p>解决方案：苹果系统升级OS X EL Capitan后会出现的插件错误，将安装流程 4.安装CocoaPods 的 (1)sudo gem install cocoapods ——&gt;改为sudo gem install -n /usr/local/bin cocoapods</p>
<p>错误3：</p>
<p>[!] Unable to satisfy the following requirements: - <code>AVOSCloud (~&gt; 3.1.6.3)</code> required by <code>Podfile</code></p>
<p>Specs satisfying the <code>AVOSCloud (~&gt; 3.1.6.3)</code> dependency were found, but they required a higher minimum deployment target.</p>
<p>解决方案：安装流程：Podfile文件 中   platform:ios, ‘6.0’  后边的 6.0 是平台版本号 ，一定要加上</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工具/">工具</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-端午节骑行杭州至黄山计划" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/25/端午节骑行杭州至黄山计划/" class="article-date">
  	<time datetime="2016-05-25T03:19:11.000Z" itemprop="datePublished">2016-05-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/25/端午节骑行杭州至黄山计划/">端午节骑行杭州至黄山计划</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<h3 id="出行概要"><a href="#出行概要" class="headerlink" title="出行概要"></a>出行概要</h3></blockquote>
<p>活动时间：2016.6.9–2016.6.11</p>
<p>活动目的：骑游，赏景</p>
<p>道路状况：平坦路面为主</p>
<p>出发时间：2016.6.9</p>
<p>回程时间：2016.6.11</p>
<p>路程：270KM+</p>
<p>活动强度：一般</p>
<p>活动费用：含路费计划500以内</p>
<p>联系人：Tweiwei497435786[微信] </p>
<blockquote>
<h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h3></blockquote>
<p>行者路书编号：628742</p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/hangzhou_huangshan_lushu2.png" alt="Markdown preferences pane"></p>
<blockquote>
<h3 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h3></blockquote>
<h4 id="Day1-杭州东方电子商务园－临安－绩溪县霞坑镇（180KM）"><a href="#Day1-杭州东方电子商务园－临安－绩溪县霞坑镇（180KM）" class="headerlink" title="Day1 杭州东方电子商务园－临安－绩溪县霞坑镇（180KM）"></a>Day1 杭州东方电子商务园－临安－绩溪县霞坑镇（180KM）</h4><p><code>6.9 周四</code>6:30（东方电子商务园南门）集合出发，预计下午7:00左右到达，选择宾馆住宿。</p>
<p>路况：</p>
<p>杭州天气：</p>
<h4 id="Day2-绩溪县霞坑镇－黄山风景区（实际骑行90KM-徒步黄山3小时）"><a href="#Day2-绩溪县霞坑镇－黄山风景区（实际骑行90KM-徒步黄山3小时）" class="headerlink" title="Day2 绩溪县霞坑镇－黄山风景区（实际骑行90KM+徒步黄山3小时）"></a>Day2 绩溪县霞坑镇－黄山风景区（实际骑行90KM+徒步黄山3小时）</h4><p><code>6.10 周五</code>6:30（绩溪县霞坑镇露营点）集合出发，预计下午1:00左右到达汤口镇景点入口，休整后徒步3小时到达山顶，晚上山顶露营。</p>
<p>路况：</p>
<p>杭州天气：</p>
<p>黄山天气：</p>
<h4 id="Day3-黄山游玩－乘车回程"><a href="#Day3-黄山游玩－乘车回程" class="headerlink" title="Day3 黄山游玩－乘车回程"></a>Day3 黄山游玩－乘车回程</h4><p><code>6.11 周六</code>早起看日出，游玩黄山后，下午3点左右在汤口镇乘坐大巴回杭州黄龙（时长3小时），预计7点左右到杭州。</p>
<p>黄山天气：</p>
<p>杭州天气：</p>
<blockquote>
<h3 id="预计费用"><a href="#预计费用" class="headerlink" title="预计费用"></a>预计费用</h3></blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">费用</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">住宿</td>
<td style="text-align:center">未知</td>
<td style="text-align:center">自带帐篷</td>
</tr>
<tr>
<td style="text-align:center">餐费</td>
<td style="text-align:center">3 * 50 ＝ 150</td>
<td style="text-align:center">餐费包含水</td>
</tr>
<tr>
<td style="text-align:center">景区门票</td>
<td style="text-align:center">230</td>
<td style="text-align:center">该项可能取消，联票</td>
</tr>
<tr>
<td style="text-align:center">车费</td>
<td style="text-align:center">110</td>
<td style="text-align:center">黄山风景区汤口到杭州黄龙大巴费用，不包含自行车费用</td>
</tr>
<tr>
<td style="text-align:center">其它费用</td>
<td style="text-align:center">未知</td>
<td style="text-align:center">包含个人消费等</td>
</tr>
<tr>
<td style="text-align:center">总计</td>
<td style="text-align:center">490</td>
<td style="text-align:center">当前费用为大概统计，具体依据消费而定</td>
</tr>
</tbody>
</table>
<blockquote>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></blockquote>
<p>1.黄山景区物价较贵，建议自备干粮，山顶早晚温差较大，建议备足衣物。</p>
<p>2.如果遇期间下雨，本活动自动取消。</p>
<p>3.期望大家能够在出游之前提出更多的建议，将会根据相关建议做出修改。让大家都能有一个开心，快乐的美好骑行游玩时间。</p>
<p>4.戴好头盔手套与能量补给；需要带基本衣物，手电，防雨装备，防晒，基本药物等。</p>
<p>5.本次出行采取露营方式，需要自备帐篷。</p>
<blockquote>
<h3 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h3></blockquote>
<p>1.本活动是自发的，有一定的危险性，参加者须对自己的安全负责。活动中当由于意外事故或急性疾病等不可预测因素造成身体损伤时，团队的其他成员会尽全力救助，但不承担任何法律和经济责任，望能理解</p>
<p>2.任何参与本活动的人均视为同意此免责声明</p>
<blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3></blockquote>
<p>1.<a href="http://jingyan.baidu.com/article/e8cdb32b7f78b237052bad38.html" target="_blank" rel="external">黄山最佳观日出地点有哪些？</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/旅行计划/">旅行计划</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Git-Hooks" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/16/Git-Hooks/" class="article-date">
  	<time datetime="2016-05-16T03:50:42.000Z" itemprop="datePublished">2016-05-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/16/Git-Hooks/">Git Hooks</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Git 本身可以调用自定义的挂钩脚本，其中有两组：客户端和服务器端。客户端挂钩用于客户端的操作，如提交和合并。服务器端挂钩用于 Git 服务器端的操作，如接收被推送的提交。</p>
</blockquote>
<p>进入当前的项目的目录，执行如下命令，会看到git下面hooks包含的hook操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .git/hooks/</span><br></pre></td></tr></table></figure>
<p>Git的挂钩(Hook)主要包含：</p>
<ul>
<li>applypatch-msg.sample*</li>
<li>commit-msg.sample* </li>
<li>post-update.sample*</li>
<li>pre-applypatch.sample*</li>
<li>pre-commit.sample*</li>
<li>pre-push.sample*</li>
<li>pre-rebase.sample*</li>
<li>prepare-commit-msg.sample*</li>
<li>update.sample*</li>
<li>……</li>
</ul>
<p>有了这些hooks，我们可以对git过程操作进行hook操作，其中在以下一些场景中会有实际的应用:</p>
<p>1.<a href="http://tweiwei497435786.github.io/2016/04/05/ClangFormat代码格式化/" target="_blank" rel="external">ClangFormat代码格式化</a>其中对pre-commit进行了提交代码到git之前的hook操作，可以检查代码的格式是否符合一定的规范.</p>
<p>2.当然我们在进行图形化工具进行checkout，post-merge之后进行post-checkout，post-merge的hook操作，添加脚本自动执行pod的pod update自动操作省去手动pod库文件的操作。</p>
<p>3.我们提交代码到主分之的时候，先做pre-merge的hook操作，检查是否能够通过编译，通过编译的情况下才能合并到主分之。</p>
<p>4……</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀</p>
<p>2.对文件我们需要增加执行权限<code>chmod +x “文件名称”</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://gitbook.liuhui998.com/index.html" target="_blank" rel="external">Git Community Book 中文版</a></p>
<p>2.<a href="https://git-scm.com/book/zh/v2/自定义-Git-Git-钩子" target="_blank" rel="external">自定义 Git - Git 钩子</a></p>
<p>3.<a href="http://blog.csdn.net/haydenwang8287/article/details/1753883" target="_blank" rel="external"> linux文件权限查看及修改-chmod ——入门的一些常识</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS开发/">iOS开发</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-JSPatch" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/11/JSPatch/" class="article-date">
  	<time datetime="2016-05-11T03:38:02.000Z" itemprop="datePublished">2016-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/11/JSPatch/">JSPatch</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>上架后的 应用 可能会遇到的一些突发状况 , 未测出的Crash、临时改点小需求 , 等等 , 我们总不能每次因为一点小改动就重新提交一次 App Store , 先不说 App Store 的审核时间 , 频繁的让用户去更新应用 , 用户也会烦的 。使用这篇文章所讲的来实现动态更新是再合适不过了</p>
</blockquote>
<h3 id="动态更新方案"><a href="#动态更新方案" class="headerlink" title="动态更新方案"></a>动态更新方案</h3><ul>
<li>JSPatch (代码量少，强大持续有人维护，js语言，appstore审核可通过）</li>
<li><a href="https://github.com/alibaba/wax" target="_blank" rel="external">alibaba/wax</a>(阿里巴巴主推)</li>
<li><a href="https://github.com/mmin18/WaxPatch" target="_blank" rel="external">WaxPatch</a></li>
<li>脚本</li>
<li>….</li>
</ul>
<h3 id="基础原理"><a href="#基础原理" class="headerlink" title="基础原理"></a>基础原理</h3><p>JSPatch用iOS内置的JavaScriptCore.framework作为JS引擎，但没有用它JSExport的特性进行JS-OC函数互调，而是通过Objective-C Runtime，从JS传递要调用的类名函数名到Objective-C，再使用NSInvocation动态调用对应的OC方法。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>按照<a href="http://www.jspatch.com/Docs/intro" target="_blank" rel="external">JSPatch Platform</a>进行下载SDK,按照指示接入SDK。简单方便无需要考虑后台搭建，安全等问题，达到一定的用户日活量需要收费。</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">JSPatch</a>下载代码，或者通过pod管理方式引入JSPatch文件。如果只是在本地调用测试js代码是否作用，只需要调用如代码,并在jsPatchTest.js中加入测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *sourcePath = [[NSBundle mainBundle] pathForResource:@&quot;jsPatchTest&quot; ofType:@&quot;js&quot;];</span><br><span class="line">NSString *script = [NSString stringWithContentsOfFile:sourcePath encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line">[JPEngine startEngine];</span><br><span class="line">[JPEngine evaluateScript:script];</span><br></pre></td></tr></table></figure>
<p>如上仅仅是本地js代码测试，发布线上我们需要有自己的后台下发脚本，每次客户端启动app非实时或者becomeActivity实时检测最新的hotfix的脚本，根据当前的用户app的版本和hotfix的版本，用户自动请求下载脚本后保存在本地。在这一过程中可能会被劫持造成不可控的安全问题，为此我们需要在后台进行MD5或者RSA等加密，移动端进行解密操作，确保安全问题。</p>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>Github 开源的是 JSPatch 核心代码，使用完全免费自由，若打算自己搭建后台下发 JSPatch 脚本，可以直接使用 github 上的核心代码，与 JSPatch 平台上的 SDK 无关。JSPatch 平台的 SDK 在核心代码的基础上增加了向平台请求脚本/传输解密/版本管理等功能，只用于这个平台。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1.定义为ivar的成员，无法获取，特别注意。属性的访问都是通过方法调用的形式。所以代码中不要使用ivar定义成员。</p>
<p>2.注意写代码的时候能够拆分的代码，尽量简洁干净。避免hotfix的时候，需要重写大量的内容。</p>
<p>3.JSPatch获取OC class名称的方法，用于OC判读是否属于某一个类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.__clsDeclaration //返回的是一个字符串，通过比较改字符串与类名的字符串是否相等可以判断obj的类型。 应用于新版的JSPatch</span><br><span class="line">obj.__clsName //对于使用老版本的JSPatch需要使用该字段来获取class名称</span><br></pre></td></tr></table></figure>
<h3 id="hotfix代码示例"><a href="#hotfix代码示例" class="headerlink" title="hotfix代码示例"></a>hotfix代码示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defineClass(&quot;BBNewMainView&quot;, &#123;</span><br><span class="line">            // instance method definitions</span><br><span class="line">        reloadDynamicBanners:function() &#123;</span><br><span class="line">            require(&apos;BBSquareAdsView,BBAdsCollectionView&apos;);</span><br><span class="line">            var adsCollectionViewJS = self.adsCollectionView();</span><br><span class="line">            var squareAdsView = self.squareAdsView();//定义为ivar的成员，无法获取，特别注意。属性的访问都是通过方法调用的形式</span><br><span class="line">            var adsTop = adsCollectionViewJS.frame().y;//注意该地方获取origin.y的方式，相关文档上面存在错误</span><br><span class="line">            var adsHeight = adsCollectionViewJS.frame().height;</span><br><span class="line">            var adsBottom = adsTop + adsHeight;</span><br><span class="line">            squareAdsView.setFrame(&#123;x:0, y:parseInt(adsBottom), width:0, height:0&#125;);//注意这里parseInt(adsBottom)，转换为int类型的</span><br><span class="line">            self.ORIGreloadDynamicBanners(); //添加ORIG前缀表示调用oc中的原始方法</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://www.jspatch.com/Docs/intro" target="_blank" rel="external">JSPatch官网</a></p>
<p>2.<a href="https://github.com/bang590/JSPatch" target="_blank" rel="external">JSPatch的Github链接</a></p>
<p>3.<a href="http://bang590.github.io/JSPatchConvertor/" target="_blank" rel="external">OC转换为JSPatch</a>（不是万能的）</p>
<p>4.<a href="http://www.cocoachina.com/ios/20150708/12467.html" target="_blank" rel="external">JSPatch实现原理详解</a></p>
<p>5.<a href="http://bluereader.org/article/52429965" target="_blank" rel="external">iOS应用架构谈 动态部署方案</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Code-Snippets" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/10/Code-Snippets/" class="article-date">
  	<time datetime="2016-05-10T13:23:24.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/10/Code-Snippets/">Code Snippets</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>code snippets可以提供一些代码片段的操作，可以节省输入需要的时间。类似于系统的输入字母后的提示效果，点击确定后自动填充。根据下面的步骤可以实现一个简单的snippets。甚至你可以创建自己snippets的library</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1.输入你想要的snippets,如下(对代理的内容进行编写snippets，防止开发人员写错属性及节省时间）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;BBMartshowDetailDelegate&gt; martshowDetailDelegate;</span><br></pre></td></tr></table></figure>
<p>2.然后单击并按住代码块，直到文本光标变为箭头光标。接着将代码块拖放到code snippet library中，然后松开鼠标,弹出视图即使snippets内容，修改title(snippet的名称),Commpletion Short(快捷数据的内容),Platform,Language等。如下图的展示，我在这里取得名字property delegate(snippets中的名称),Completion Shortcut为pd（快捷输入提示）,Completion Scopes设置为Class Interface Methods表示只在.h中才会起作用：</p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/1C0CBECF-6991-4960-ABC8-426B4F5174B9.png" alt="General preferences pane"></p>
<p>3.修改文本框的内容，如下(&lt;#content#&gt;)表示可以替换的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;&lt;#BBMartshowDetailDelegate#&gt;&gt; &lt;#mde&gt;#;</span><br></pre></td></tr></table></figure>
<p>4.在.h的文件的属性声明的地方输入<code>pd</code>xcode将会自动提示，点击enter确认即可。或者通过选中snippets拖入代码中也可以。</p>
<p>5.当然我们也可以修改当前的snippets，只需要双击snippets，然后edit即可。</p>
<p>下面会通过gif图展示该如何操作：</p>
<p><img src="https://raw.githubusercontent.com/Tweiwei497435786/HexoResource/master/article/2016-05-10%2021_07_57.gif" alt="General preferences pane"></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/iOS开发/">iOS开发</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Tortoise
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>